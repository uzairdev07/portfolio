import _extends from '@babel/runtime/helpers/esm/extends';
import * as THREE from 'three';
import * as React from 'react';
import { extend, useThree, useFrame } from '@react-three/fiber';
import { RenderTexture } from './RenderTexture.js';
import { shaderMaterial } from './shaderMaterial.js';

const PortalMaterial = shaderMaterial({
  map: null,
  resolution: new THREE.Vector2()
}, `void main() {
     gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
   }`, `uniform sampler2D map;
   uniform vec2 resolution;
   void main() {
     vec2 uv = gl_FragCoord.xy / resolution.xy;
     vec4 t = texture2D(map, uv);
     gl_FragColor = texture2D(map, uv);
     #include <tonemapping_fragment>
     #include <encodings_fragment>
   }`);
const MeshPortalMaterial = /*#__PURE__*/React.forwardRef(({
  children,
  ...props
}, fref) => {
  extend({
    PortalMaterial
  });
  const ref = React.useRef(null);
  const group = React.useRef(null);
  const {
    size,
    events,
    viewport
  } = useThree();
  useFrame(() => {
    var _ref$current;

    let parent = (_ref$current = ref.current) == null ? void 0 : _ref$current.__r3f.parent;

    if (parent) {
      group.current.matrix.copy(parent.matrixWorld);
    }
  });
  React.useImperativeHandle(fref, () => ref.current);
  return /*#__PURE__*/React.createElement("portalMaterial", _extends({
    // @ts-ignore
    ref: ref,
    resolution: [size.width * viewport.dpr, size.height * viewport.dpr],
    toneMapped: false
  }, props), /*#__PURE__*/React.createElement(RenderTexture, {
    attach: "map",
    compute: events.compute
  }, /*#__PURE__*/React.createElement("group", {
    onPointerOver: () => null,
    matrixAutoUpdate: false,
    ref: group
  }, children)));
});

export { MeshPortalMaterial };
